"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>{\n            tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\";\n        })) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            },\n            generateId\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = generateId();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else if (streamedResponse.startsWith('{\"tool_calls\":')) {\n                responseMessage[\"tool_calls\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (streamedResponse.startsWith('{\"tool_calls\":')) {\n            const parsedToolCalls = JSON.parse(streamedResponse).tool_calls;\n            responseMessage[\"tool_calls\"] = parsedToolCalls;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, onResponse, onFinish, onError, credentials, headers, body, generateId = nanoid } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n        if (isComplexMode) {\n            for await (const { type, value } of readDataStream(reader, {\n                isAborted: ()=>abortController === null\n            })){\n                switch(type){\n                    case \"text\":\n                        {\n                            result += value;\n                            setCompletion(result);\n                            break;\n                        }\n                    case \"data\":\n                        {\n                            onData == null ? void 0 : onData(value);\n                            break;\n                        }\n                }\n            }\n        } else {\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                setCompletion(result);\n                if (abortController === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction experimental_useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a, _b;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            body: JSON.stringify({\n                ...body,\n                // always use user-provided threadId when available:\n                threadId: (_b = threadIdParam != null ? threadIdParam : threadId) != null ? _b : null,\n                message: input,\n                // optional request data:\n                data: requestOptions == null ? void 0 : requestOptions.data\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        try {\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : \"\",\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnRTtBQUMzQjs7QUNjckMsSUFBTU0saUJBQWtEO0lBQ3REQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFFQSxJQUFNRyx5QkFJRjtJQUNGTixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQ0VBLFNBQVMsUUFDVCxPQUFPQSxVQUFVLFlBQ2pCLENBQUUsb0JBQW1CQSxLQUFBLEtBQ3JCLE9BQU9BLE1BQU1JLGFBQUEsS0FBa0IsWUFDL0JKLE1BQU1JLGFBQUEsSUFBaUIsUUFDdkIsQ0FBRSxXQUFVSixNQUFNSSxhQUFBLEtBQ2xCLENBQUUsZ0JBQWVKLE1BQU1JLGFBQUEsS0FDdkIsT0FBT0osTUFBTUksYUFBQSxDQUFjTixJQUFBLEtBQVMsWUFDcEMsT0FBT0UsTUFBTUksYUFBQSxDQUFjQyxTQUFBLEtBQWMsVUFDekM7WUFDQSxNQUFNLElBQUlKLE1BQ1I7UUFFSjtRQUVBLE9BQU87WUFDTEMsTUFBTTtZQUNORjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQU1NLGlCQUE0RDtJQUNoRVQsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLENBQUNPLE1BQU1DLE9BQUEsQ0FBUVIsUUFBUTtZQUN6QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBRUEsSUFBTVMsa0JBQW9EO0lBQ3hEWixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMs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LXJhZy8uLi91c2UtY2hhdC50cz84ODI4Iiwid2VicGFjazovL2doLXJhZy8uLi8uLi9zaGFyZWQvc3RyZWFtLXBhcnRzLnRzP2M0YTgiLCJ3ZWJwYWNrOi8vZ2gtcmFnLy4uLy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzPzE4ZjEiLCJ3ZWJwYWNrOi8vZ2gtcmFnLy4uLy4uL3NoYXJlZC91dGlscy50cz9mOGNmIiwid2VicGFjazovL2doLXJhZy8uLi8uLi9zaGFyZWQvcGFyc2UtY29tcGxleC1yZXNwb25zZS50cz82NWUwIiwid2VicGFjazovL2doLXJhZy8uLi8uLi9zaGFyZWQvY2FsbC1jaGF0LWFwaS50cz9iNTViIiwid2VicGFjazovL2doLXJhZy8uLi8uLi9zaGFyZWQvcHJvY2Vzcy1jaGF0LXN0cmVhbS50cz84ZDdmIiwid2VicGFjazovL2doLXJhZy8uLi91c2UtY29tcGxldGlvbi50cz9hZTdmIiwid2VicGFjazovL2doLXJhZy8uLi8uLi9zaGFyZWQvY2FsbC1jb21wbGV0aW9uLWFwaS50cz84NTI1Iiwid2VicGFjazovL2doLXJhZy8uLi91c2UtYXNzaXN0YW50LnRzPzI4MTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSWQsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU1dSLCB7IEtleWVkTXV0YXRvciB9IGZyb20gJ3N3cic7XG5pbXBvcnQgeyBjYWxsQ2hhdEFwaSB9IGZyb20gJy4uL3NoYXJlZC9jYWxsLWNoYXQtYXBpJztcbmltcG9ydCB7IHByb2Nlc3NDaGF0U3RyZWFtIH0gZnJvbSAnLi4vc2hhcmVkL3Byb2Nlc3MtY2hhdC1zdHJlYW0nO1xuaW1wb3J0IHR5cGUge1xuICBDaGF0UmVxdWVzdCxcbiAgQ2hhdFJlcXVlc3RPcHRpb25zLFxuICBDcmVhdGVNZXNzYWdlLFxuICBJZEdlbmVyYXRvcixcbiAgSlNPTlZhbHVlLFxuICBNZXNzYWdlLFxuICBVc2VDaGF0T3B0aW9ucyxcbn0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gJy4uL3NoYXJlZC91dGlscyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlYWN0UmVzcG9uc2VSb3csXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlLFxufSBmcm9tICcuLi9zdHJlYW1zL3N0cmVhbWluZy1yZWFjdC1yZXNwb25zZSc7XG5leHBvcnQgdHlwZSB7IENyZWF0ZU1lc3NhZ2UsIE1lc3NhZ2UsIFVzZUNoYXRPcHRpb25zIH07XG5cbmV4cG9ydCB0eXBlIFVzZUNoYXRIZWxwZXJzID0ge1xuICAvKiogQ3VycmVudCBtZXNzYWdlcyBpbiB0aGUgY2hhdCAqL1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuICAvKiogVGhlIGVycm9yIG9iamVjdCBvZiB0aGUgQVBJIHJlcXVlc3QgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IEVycm9yO1xuICAvKipcbiAgICogQXBwZW5kIGEgdXNlciBtZXNzYWdlIHRvIHRoZSBjaGF0IGxpc3QuIFRoaXMgdHJpZ2dlcnMgdGhlIEFQSSBjYWxsIHRvIGZldGNoXG4gICAqIHRoZSBhc3Npc3RhbnQncyByZXNwb25zZS5cbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkgY2FsbFxuICAgKi9cbiAgYXBwZW5kOiAoXG4gICAgbWVzc2FnZTogTWVzc2FnZSB8IENyZWF0ZU1lc3NhZ2UsXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBSZWxvYWQgdGhlIGxhc3QgQUkgY2hhdCByZXNwb25zZSBmb3IgdGhlIGdpdmVuIGNoYXQgaGlzdG9yeS4gSWYgdGhlIGxhc3RcbiAgICogbWVzc2FnZSBpc24ndCBmcm9tIHRoZSBhc3Npc3RhbnQsIGl0IHdpbGwgcmVxdWVzdCB0aGUgQVBJIHRvIGdlbmVyYXRlIGFcbiAgICogbmV3IHJlc3BvbnNlLlxuICAgKi9cbiAgcmVsb2FkOiAoXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBBYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0IGltbWVkaWF0ZWx5LCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zIGlmIGFueS5cbiAgICovXG4gIHN0b3A6ICgpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGBtZXNzYWdlc2Agc3RhdGUgbG9jYWxseS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0b1xuICAgKiBlZGl0IHRoZSBtZXNzYWdlcyBvbiB0aGUgY2xpZW50LCBhbmQgdGhlbiB0cmlnZ2VyIHRoZSBgcmVsb2FkYCBtZXRob2RcbiAgICogbWFudWFsbHkgdG8gcmVnZW5lcmF0ZSB0aGUgQUkgcmVzcG9uc2UuXG4gICAqL1xuICBzZXRNZXNzYWdlczogKG1lc3NhZ2VzOiBNZXNzYWdlW10pID0+IHZvaWQ7XG4gIC8qKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgKi9cbiAgaW5wdXQ6IHN0cmluZztcbiAgLyoqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuICAvKiogQW4gaW5wdXQvdGV4dGFyZWEtcmVhZHkgb25DaGFuZ2UgaGFuZGxlciB0byBjb250cm9sIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgKi9cbiAgaGFuZGxlSW5wdXRDaGFuZ2U6IChcbiAgICBlOlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuICAvKiogRm9ybSBzdWJtaXNzaW9uIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSByZXNldCBpbnB1dCBhbmQgYXBwZW5kIGEgdXNlciBtZXNzYWdlICovXG4gIGhhbmRsZVN1Ym1pdDogKFxuICAgIGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIGNoYXRSZXF1ZXN0T3B0aW9ucz86IENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiB2b2lkO1xuICBtZXRhZGF0YT86IE9iamVjdDtcbiAgLyoqIFdoZXRoZXIgdGhlIEFQSSByZXF1ZXN0IGlzIGluIHByb2dyZXNzICovXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgLyoqIEFkZGl0aW9uYWwgZGF0YSBhZGRlZCBvbiB0aGUgc2VydmVyIHZpYSBTdHJlYW1EYXRhICovXG4gIGRhdGE/OiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZDtcbn07XG5cbnR5cGUgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbiA9IChwYXlsb2FkOiB7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSkgPT4gUHJvbWlzZTxleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZT47XG5cbmNvbnN0IGdldFN0cmVhbWVkUmVzcG9uc2UgPSBhc3luYyAoXG4gIGFwaTogc3RyaW5nIHwgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbixcbiAgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0LFxuICBtdXRhdGU6IEtleWVkTXV0YXRvcjxNZXNzYWdlW10+LFxuICBtdXRhdGVTdHJlYW1EYXRhOiBLZXllZE11dGF0b3I8SlNPTlZhbHVlW10gfCB1bmRlZmluZWQ+LFxuICBleGlzdGluZ0RhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuICBleHRyYU1ldGFkYXRhUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGFueT4sXG4gIG1lc3NhZ2VzUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE1lc3NhZ2VbXT4sXG4gIGFib3J0Q29udHJvbGxlclJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxBYm9ydENvbnRyb2xsZXIgfCBudWxsPixcbiAgZ2VuZXJhdGVJZDogSWRHZW5lcmF0b3IsXG4gIG9uRmluaXNoPzogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQsXG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPixcbiAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcz86IGJvb2xlYW4sXG4pID0+IHtcbiAgLy8gRG8gYW4gb3B0aW1pc3RpYyB1cGRhdGUgdG8gdGhlIGNoYXQgc3RhdGUgdG8gc2hvdyB0aGUgdXBkYXRlZCBtZXNzYWdlc1xuICAvLyBpbW1lZGlhdGVseS5cbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlcyA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gIG11dGF0ZShjaGF0UmVxdWVzdC5tZXNzYWdlcywgZmFsc2UpO1xuXG4gIGNvbnN0IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkID0gc2VuZEV4dHJhTWVzc2FnZUZpZWxkc1xuICAgID8gY2hhdFJlcXVlc3QubWVzc2FnZXNcbiAgICA6IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLm1hcChcbiAgICAgICAgKHsgcm9sZSwgY29udGVudCwgbmFtZSwgZnVuY3Rpb25fY2FsbCwgdG9vbF9jYWxscywgdG9vbF9jYWxsX2lkIH0pID0+ICh7XG4gICAgICAgICAgcm9sZSxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAuLi4obmFtZSAhPT0gdW5kZWZpbmVkICYmIHsgbmFtZSB9KSxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLi4uKHRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sX2NhbGxzLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgaWYgKHR5cGVvZiBhcGkgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBhcmUgaGFuZGxpbmcgYSBTZXJ2ZXIgQWN0aW9uLiBObyBjb21wbGV4IG1vZGUgaGFuZGxpbmcgbmVlZGVkLlxuXG4gICAgY29uc3QgcmVwbHlJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRSb3cocHJvbWlzZTogUHJvbWlzZTxSZWFjdFJlc3BvbnNlUm93Pikge1xuICAgICAgY29uc3QgeyBjb250ZW50LCB1aSwgbmV4dCB9ID0gYXdhaXQgcHJvbWlzZTtcblxuICAgICAgLy8gVE9ETzogSGFuZGxlIGZ1bmN0aW9uIGNhbGxzLlxuICAgICAgcmVzcG9uc2VNZXNzYWdlWydjb250ZW50J10gPSBjb250ZW50O1xuICAgICAgcmVzcG9uc2VNZXNzYWdlWyd1aSddID0gYXdhaXQgdWk7XG5cbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIHsgLi4ucmVzcG9uc2VNZXNzYWdlIH1dLCBmYWxzZSk7XG5cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBhcGkoe1xuICAgICAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgYXMgTWVzc2FnZVtdLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgfSkgYXMgUHJvbWlzZTxSZWFjdFJlc3BvbnNlUm93PjtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgbWVzc2FnZXMgaWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBjYWxsQ2hhdEFwaSh7XG4gICAgYXBpLFxuICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAuLi5jaGF0UmVxdWVzdC5vcHRpb25zPy5ib2R5LFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnMsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QudG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIHRvb2xzOiBjaGF0UmVxdWVzdC50b29scyxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICB0b29sX2Nob2ljZTogY2hhdFJlcXVlc3QudG9vbF9jaG9pY2UsXG4gICAgICB9KSxcbiAgICB9LFxuICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgaGVhZGVyczoge1xuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsXG4gICAgICAuLi5jaGF0UmVxdWVzdC5vcHRpb25zPy5oZWFkZXJzLFxuICAgIH0sXG4gICAgYWJvcnRDb250cm9sbGVyOiAoKSA9PiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCxcbiAgICBhcHBlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIG1lc3NhZ2VdLCBmYWxzZSk7XG4gICAgfSxcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKSB7XG4gICAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgIH0sXG4gICAgb25SZXNwb25zZSxcbiAgICBvblVwZGF0ZShtZXJnZWQsIGRhdGEpIHtcbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIC4uLm1lcmdlZF0sIGZhbHNlKTtcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLihleGlzdGluZ0RhdGEgfHwgW10pLCAuLi4oZGF0YSB8fCBbXSldLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkLFxuICB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGF0KHtcbiAgYXBpID0gJy9hcGkvY2hhdCcsXG4gIGlkLFxuICBpbml0aWFsTWVzc2FnZXMsXG4gIGluaXRpYWxJbnB1dCA9ICcnLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGdlbmVyYXRlSWQgPSBuYW5vaWQsXG59OiBPbWl0PFVzZUNoYXRPcHRpb25zLCAnYXBpJz4gJiB7XG4gIGFwaT86IHN0cmluZyB8IFN0cmVhbWluZ1JlYWN0UmVzcG9uc2VBY3Rpb247XG4gIGtleT86IHN0cmluZztcbn0gPSB7fSk6IFVzZUNoYXRIZWxwZXJzIHtcbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIHRoZSBjaGF0IGlmIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgaWRLZXkgPSBpZCA/PyBob29rSWQ7XG4gIGNvbnN0IGNoYXRLZXkgPSB0eXBlb2YgYXBpID09PSAnc3RyaW5nJyA/IFthcGksIGlkS2V5XSA6IGlkS2V5O1xuXG4gIC8vIFN0b3JlIGEgZW1wdHkgYXJyYXkgYXMgdGhlIGluaXRpYWwgbWVzc2FnZXNcbiAgLy8gKGluc3RlYWQgb2YgdXNpbmcgYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSB0aGF0IGdldHMgcmUtY3JlYXRlZCBlYWNoIHRpbWUpXG4gIC8vIHRvIGF2b2lkIHJlLXJlbmRlcnM6XG4gIGNvbnN0IFtpbml0aWFsTWVzc2FnZXNGYWxsYmFja10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgLy8gU3RvcmUgdGhlIGNoYXQgc3RhdGUgaW4gU1dSLCB1c2luZyB0aGUgY2hhdElkIGFzIHRoZSBrZXkgdG8gc2hhcmUgc3RhdGVzLlxuICBjb25zdCB7IGRhdGE6IG1lc3NhZ2VzLCBtdXRhdGUgfSA9IHVzZVNXUjxNZXNzYWdlW10+KFxuICAgIFtjaGF0S2V5LCAnbWVzc2FnZXMnXSxcbiAgICBudWxsLFxuICAgIHsgZmFsbGJhY2tEYXRhOiBpbml0aWFsTWVzc2FnZXMgPz8gaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2sgfSxcbiAgKTtcblxuICAvLyBXZSBzdG9yZSBsb2FkaW5nIHN0YXRlIGluIGFub3RoZXIgaG9vayB0byBzeW5jIGxvYWRpbmcgc3RhdGVzIGFjcm9zcyBob29rIGludm9jYXRpb25zXG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSPGJvb2xlYW4+KFxuICAgIFtjaGF0S2V5LCAnbG9hZGluZyddLFxuICAgIG51bGwsXG4gICk7XG5cbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjxcbiAgICBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZFxuICA+KFtjaGF0S2V5LCAnc3RyZWFtRGF0YSddLCBudWxsKTtcblxuICBjb25zdCB7IGRhdGE6IGVycm9yID0gdW5kZWZpbmVkLCBtdXRhdGU6IHNldEVycm9yIH0gPSB1c2VTV1I8XG4gICAgdW5kZWZpbmVkIHwgRXJyb3JcbiAgPihbY2hhdEtleSwgJ2Vycm9yJ10sIG51bGwpO1xuXG4gIC8vIEtlZXAgdGhlIGxhdGVzdCBtZXNzYWdlcyBpbiBhIHJlZi5cbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWY8TWVzc2FnZVtdPihtZXNzYWdlcyB8fCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzIHx8IFtdO1xuICB9LCBbbWVzc2FnZXNdKTtcblxuICAvLyBBYm9ydCBjb250cm9sbGVyIHRvIGNhbmNlbCB0aGUgY3VycmVudCBBUEkgY2FsbC5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmPEFib3J0Q29udHJvbGxlciB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuXG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcblxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuXG4gICAgICAgIGF3YWl0IHByb2Nlc3NDaGF0U3RyZWFtKHtcbiAgICAgICAgICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PlxuICAgICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZShcbiAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgICAgICAgICBzdHJlYW1EYXRhISxcbiAgICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgICAgICAgICAgZ2VuZXJhdGVJZCxcbiAgICAgICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdDogY2hhdFJlcXVlc3RQYXJhbSA9PiB7XG4gICAgICAgICAgICBjaGF0UmVxdWVzdCA9IGNoYXRSZXF1ZXN0UGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXM6ICgpID0+IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZ25vcmUgYWJvcnQgZXJyb3JzIGFzIHRoZXkgYXJlIGV4cGVjdGVkLlxuICAgICAgICBpZiAoKGVyciBhcyBhbnkpLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RXJyb3IoZXJyIGFzIEVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgZ2VuZXJhdGVJZCxcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IGFwcGVuZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChcbiAgICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgICAge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIHRvb2xzLFxuICAgICAgICB0b29sX2Nob2ljZSxcbiAgICAgICAgZGF0YSxcbiAgICAgIH06IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgICkgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuY29uY2F0KG1lc3NhZ2UgYXMgTWVzc2FnZSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkXSxcbiAgKTtcblxuICBjb25zdCByZWxvYWQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoe1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICB0b29scyxcbiAgICAgIHRvb2xfY2hvaWNlLFxuICAgIH06IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBSZW1vdmUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZSBhbmQgcmV0cnkgbGFzdCB1c2VyIG1lc3NhZ2UuXG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzUmVmLmN1cnJlbnRbbWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAuLi4odG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xzIH0pLFxuICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF0sXG4gICk7XG5cbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2V0TWVzc2FnZXMgPSB1c2VDYWxsYmFjayhcbiAgICAobWVzc2FnZXM6IE1lc3NhZ2VbXSkgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXM7XG4gICAgfSxcbiAgICBbbXV0YXRlXSxcbiAgKTtcblxuICAvLyBJbnB1dCBzdGF0ZSBhbmQgaGFuZGxlcnMuXG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoXG4gICAgICBlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICAgIG9wdGlvbnM6IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgICAgbWV0YWRhdGE/OiBPYmplY3QsXG4gICAgKSA9PiB7XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCxcbiAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xuXG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcbiAgICAgIHNldElucHV0KCcnKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXSxcbiAgKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlOiBhbnkpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgW10sXG4gICAgZXJyb3IsXG4gICAgYXBwZW5kLFxuICAgIHJlbG9hZCxcbiAgICBzdG9wLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIEFzc2lzdGFudE1lc3NhZ2UsXG4gIERhdGFNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgU3RyZWFtU3RyaW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtUGFydDxDT0RFIGV4dGVuZHMgc3RyaW5nLCBOQU1FIGV4dGVuZHMgc3RyaW5nLCBUWVBFPiB7XG4gIGNvZGU6IENPREU7XG4gIG5hbWU6IE5BTUU7XG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4geyB0eXBlOiBOQU1FOyB2YWx1ZTogVFlQRSB9O1xufVxuXG5jb25zdCB0ZXh0U3RyZWFtUGFydDogU3RyZWFtUGFydDwnMCcsICd0ZXh0Jywgc3RyaW5nPiA9IHtcbiAgY29kZTogJzAnLFxuICBuYW1lOiAndGV4dCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgZnVuY3Rpb25DYWxsU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzEnLFxuICAnZnVuY3Rpb25fY2FsbCcsXG4gIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH1cbj4gPSB7XG4gIGNvZGU6ICcxJyxcbiAgbmFtZTogJ2Z1bmN0aW9uX2NhbGwnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdmdW5jdGlvbl9jYWxsJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSAnb2JqZWN0JyB8fFxuICAgICAgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8XG4gICAgICAhKCduYW1lJyBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fFxuICAgICAgISgnYXJndW1lbnRzJyBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZnVuY3Rpb25fY2FsbFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZnVuY3Rpb25fY2FsbFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb25fY2FsbCcsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyB7IGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbCB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBkYXRhU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMicsICdkYXRhJywgQXJyYXk8SlNPTlZhbHVlPj4gPSB7XG4gIGNvZGU6ICcyJyxcbiAgbmFtZTogJ2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnZGF0YScsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBlcnJvclN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzMnLCAnZXJyb3InLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMycsXG4gIG5hbWU6ICdlcnJvcicsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdlcnJvcicsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzQnLFxuICAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICBBc3Npc3RhbnRNZXNzYWdlXG4+ID0ge1xuICBjb2RlOiAnNCcsXG4gIG5hbWU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2lkJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnY29udGVudCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuaWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdhc3Npc3RhbnQnIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS5jb250ZW50KSB8fFxuICAgICAgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAgIGl0ZW0gPT5cbiAgICAgICAgICBpdGVtICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndHlwZScgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgICAgJ3RleHQnIGluIGl0ZW0gJiZcbiAgICAgICAgICBpdGVtLnRleHQgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ3ZhbHVlJyBpbiBpdGVtLnRleHQgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSAnc3RyaW5nJyxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIEFzc2lzdGFudE1lc3NhZ2UsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzUnLFxuICAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gIHtcbiAgICB0aHJlYWRJZDogc3RyaW5nO1xuICAgIG1lc3NhZ2VJZDogc3RyaW5nO1xuICB9XG4+ID0ge1xuICBjb2RlOiAnNScsXG4gIG5hbWU6ICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndGhyZWFkSWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgnbWVzc2FnZUlkJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWQsXG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBkYXRhTWVzc2FnZVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzYnLCAnZGF0YV9tZXNzYWdlJywgRGF0YU1lc3NhZ2U+ID0ge1xuICBjb2RlOiAnNicsXG4gIG5hbWU6ICdkYXRhX21lc3NhZ2UnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdyb2xlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ2RhdGEnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnJvbGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZS5yb2xlICE9PSAnZGF0YSdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZGF0YV9tZXNzYWdlJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyBEYXRhTWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgdG9vbENhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNycsXG4gICd0b29sX2NhbGxzJyxcbiAgeyB0b29sX2NhbGxzOiBUb29sQ2FsbFtdIH1cbj4gPSB7XG4gIGNvZGU6ICc3JyxcbiAgbmFtZTogJ3Rvb2xfY2FsbHMnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0b29sX2NhbGxzJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgdmFsdWUudG9vbF9jYWxscyA9PSBudWxsIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fFxuICAgICAgdmFsdWUudG9vbF9jYWxscy5zb21lKHRjID0+IHtcbiAgICAgICAgdGMgPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0YyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdpZCcgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ3R5cGUnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy50eXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ2Z1bmN0aW9uJyBpbiB0YykgfHxcbiAgICAgICAgICB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2FyZ3VtZW50cycgaW4gdGMuZnVuY3Rpb24pIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZyc7XG4gICAgICB9KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxzXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgVG9vbENhbGxQYXlsb2FkLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndG9vbF9jYWxscycsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzgnLFxuICAnbWVzc2FnZV9hbm5vdGF0aW9ucycsXG4gIEFycmF5PEpTT05WYWx1ZT5cbj4gPSB7XG4gIGNvZGU6ICc4JyxcbiAgbmFtZTogJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZV9hbm5vdGF0aW9uc1wiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnbWVzc2FnZV9hbm5vdGF0aW9ucycsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuXSBhcyBjb25zdDtcblxuLy8gdW5pb24gdHlwZSBvZiBhbGwgc3RyZWFtIHBhcnRzXG50eXBlIFN0cmVhbVBhcnRzID1cbiAgfCB0eXBlb2YgdGV4dFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiBkYXRhU3RyZWFtUGFydFxuICB8IHR5cGVvZiBlcnJvclN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydDtcbi8qKlxuICogTWFwcyB0aGUgdHlwZSBvZiBhIHN0cmVhbSBwYXJ0IHRvIGl0cyB2YWx1ZSB0eXBlLlxuICovXG50eXBlIFN0cmVhbVBhcnRWYWx1ZVR5cGUgPSB7XG4gIFtQIGluIFN0cmVhbVBhcnRzIGFzIFBbJ25hbWUnXV06IFJldHVyblR5cGU8UFsncGFyc2UnXT5bJ3ZhbHVlJ107XG59O1xuXG5leHBvcnQgdHlwZSBTdHJlYW1QYXJ0VHlwZSA9XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdGV4dFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBkYXRhU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBlcnJvclN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5wYXJzZT47XG5cbmV4cG9ydCBjb25zdCBzdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIFtkYXRhU3RyZWFtUGFydC5jb2RlXTogZGF0YVN0cmVhbVBhcnQsXG4gIFtlcnJvclN0cmVhbVBhcnQuY29kZV06IGVycm9yU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIFRoZSBtYXAgb2YgcHJlZml4ZXMgZm9yIGRhdGEgaW4gdGhlIHN0cmVhbVxuICpcbiAqIC0gMDogVGV4dCBmcm9tIHRoZSBMTE0gcmVzcG9uc2VcbiAqIC0gMTogKE9wZW5BSSkgZnVuY3Rpb25fY2FsbCByZXNwb25zZXNcbiAqIC0gMjogY3VzdG9tIEpTT04gYWRkZWQgYnkgdGhlIHVzZXIgdXNpbmcgYERhdGFgXG4gKiAtIDY6IChPcGVuQUkpIHRvb2xfY2FsbCByZXNwb25zZXNcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiAwOlZlcmNlbFxuICogMDonc1xuICogMDogQUlcbiAqIDA6IEFJXG4gKiAwOiBTREtcbiAqIDA6IGlzIGdyZWF0XG4gKiAwOiFcbiAqIDI6IHsgXCJzb21lSnNvblwiOiBcInZhbHVlXCIgfVxuICogMToge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fVxuICogNjoge1widG9vbF9jYWxsXCI6IHtcImlkXCI6IFwidG9vbF8wXCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIiwgXCJhcmd1bWVudHNcIjogXCJ7XFxcXG5cXFxcXCJsb2NhdGlvblxcXFxcIjogXFxcXFwiQ2hhcmxvdHRlc3ZpbGxlLCBWaXJnaW5pYVxcXFxcIixcXFxcblxcXFxcImZvcm1hdFxcXFxcIjogXFxcXFwiY2Vsc2l1c1xcXFxcIlxcXFxufVwifX19XG4gKmBgYFxuICovXG5leHBvcnQgY29uc3QgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5uYW1lXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAocGFydCA9PiBwYXJ0LmNvZGUpO1xuXG4vKipcbiAqIFBhcnNlcyBhIHN0cmVhbSBwYXJ0IGZyb20gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGxpbmUgVGhlIHN0cmluZyB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgc3RyZWFtIHBhcnQuXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlU3RyZWFtUGFydCA9IChsaW5lOiBzdHJpbmcpOiBTdHJlYW1QYXJ0VHlwZSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcblxuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuJyk7XG4gIH1cblxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuXG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cblxuICBjb25zdCBjb2RlID0gcHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZTtcblxuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlOiBKU09OVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG5cbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIGEgc3RyaW5nIHdpdGggYSBwcmVmaXggZnJvbSB0aGUgYFN0cmVhbUNodW5rUHJlZml4ZXNgLCBKU09OLWlmaWVzIGl0LFxuICogYW5kIGFwcGVuZHMgYSBuZXcgbGluZS5cbiAqXG4gKiBJdCBlbnN1cmVzIHR5cGUtc2FmZXR5IGZvciB0aGUgcGFydCB0eXBlIGFuZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmVhbVBhcnQ8VCBleHRlbmRzIGtleW9mIFN0cmVhbVBhcnRWYWx1ZVR5cGU+KFxuICB0eXBlOiBULFxuICB2YWx1ZTogU3RyZWFtUGFydFZhbHVlVHlwZVtUXSxcbik6IFN0cmVhbVN0cmluZyB7XG4gIGNvbnN0IHN0cmVhbVBhcnQgPSBzdHJlYW1QYXJ0cy5maW5kKHBhcnQgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcblxuICBpZiAoIXN0cmVhbVBhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RyZWFtIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XFxuYDtcbn1cbiIsImltcG9ydCB7IFN0cmVhbVBhcnRUeXBlLCBwYXJzZVN0cmVhbVBhcnQgfSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbmNvbnN0IE5FV0xJTkUgPSAnXFxuJy5jaGFyQ29kZUF0KDApO1xuXG4vLyBjb25jYXRlbmF0ZXMgYWxsIHRoZSBjaHVua3MgaW50byBhIHNpbmdsZSBVaW50OEFycmF5XG5mdW5jdGlvbiBjb25jYXRDaHVua3MoY2h1bmtzOiBVaW50OEFycmF5W10sIHRvdGFsTGVuZ3RoOiBudW1iZXIpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNvbmNhdGVuYXRlZENodW5rcy5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBjaHVua3MubGVuZ3RoID0gMDtcblxuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHJlYWREYXRhU3RyZWFtKFxuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PixcbiAge1xuICAgIGlzQWJvcnRlZCxcbiAgfToge1xuICAgIGlzQWJvcnRlZD86ICgpID0+IGJvb2xlYW47XG4gIH0gPSB7fSxcbik6IEFzeW5jR2VuZXJhdG9yPFN0cmVhbVBhcnRUeXBlPiB7XG4gIC8vIGltcGxlbWVudGF0aW9uIG5vdGU6IHRoaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGV4IGFsZ29yaXRobSBpcyByZXF1aXJlZFxuICAvLyB0byBwYXNzIHRoZSB0ZXN0cyBpbiB0aGUgZWRnZSBlbnZpcm9ubWVudC5cblxuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rczogVWludDhBcnJheVtdID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIG5vdCBhIG5ld2xpbmUsIHdlIGhhdmUgbm90IHJlYWQgdGhlIHdob2xlIEpTT04gdmFsdWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrOyAvLyB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RyZWFtXG4gICAgfVxuXG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgIGNvbnN0IHN0cmVhbVBhcnRzID0gZGVjb2RlclxuICAgICAgLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpIC8vIHNwbGl0dGluZyBsZWF2ZXMgYW4gZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmRcbiAgICAgIC5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcblxuICAgIGZvciAoY29uc3Qgc3RyZWFtUGFydCBvZiBzdHJlYW1QYXJ0cykge1xuICAgICAgeWllbGQgc3RyZWFtUGFydDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICBpZiAoaXNBYm9ydGVkPy4oKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gJ25hbm9pZC9ub24tc2VjdXJlJztcbmltcG9ydCB7XG4gIFN0cmVhbVBhcnRUeXBlLFxuICBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxufSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbi8vIDctY2hhcmFjdGVyIHJhbmRvbSBzdHJpbmdcbmV4cG9ydCBjb25zdCBuYW5vaWQgPSBjdXN0b21BbHBoYWJldChcbiAgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcbiAgNyxcbik7XG5cbi8vIHNpbXBsZSBkZWNvZGVyIHNpZ25hdHVyZXM6XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBzdHJpbmc7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg6IGZhbHNlLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBzdHJpbmc7XG4vLyBjb21wbGV4IGRlY29kZXIgc2lnbmF0dXJlOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4OiB0cnVlLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBTdHJlYW1QYXJ0VHlwZVtdO1xuLy8gY29tYmluZWQgc2lnbmF0dXJlIGZvciB3aGVuIHRoZSBjbGllbnQgY2FsbHMgdGhpcyBmdW5jdGlvbiB3aXRoIGEgYm9vbGVhbjpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleD86IGJvb2xlYW4sXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IFN0cmVhbVBhcnRUeXBlW10gfCBzdHJpbmc7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleD86IGJvb2xlYW4pIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuXG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgICAgaWYgKCFjaHVuaykgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyXG4gICAgICAuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICcnKTsgLy8gc3BsaXR0aW5nIGxlYXZlcyBhbiBlbXB0eSBzdHJpbmcgYXQgdGhlIGVuZFxuXG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfTtcblxuZXhwb3J0IGNvbnN0IGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUgPSAoXG4gIHR5cGU6IGtleW9mIHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgdmFsdWU6IHN0cmluZyxcbik6IHZhbHVlIGlzIFN0cmVhbVN0cmluZyA9PlxuICB2YWx1ZS5zdGFydHNXaXRoKGAke1N0cmVhbVN0cmluZ1ByZWZpeGVzW3R5cGVdfTpgKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXFxuJyk7XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVN0cmluZyA9XG4gIGAkeyh0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXMpW2tleW9mIHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlc119OiR7c3RyaW5nfVxcbmA7XG5cbi8qKlxuICogQSBoZWFkZXIgc2VudCB0byB0aGUgY2xpZW50IHNvIGl0IGtub3dzIGhvdyB0byBoYW5kbGUgcGFyc2luZyB0aGUgc3RyZWFtIChhcyBhIGRlcHJlY2F0ZWQgdGV4dCByZXNwb25zZSBvciB1c2luZyB0aGUgbmV3IHByZWZpeGVkIHByb3RvY29sKVxuICovXG5leHBvcnQgY29uc3QgQ09NUExFWF9IRUFERVIgPSAnWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGEnO1xuIiwiaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHR5cGUgeyBGdW5jdGlvbkNhbGwsIEpTT05WYWx1ZSwgTWVzc2FnZSwgVG9vbENhbGwgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gJy4vdXRpbHMnO1xuXG50eXBlIFByZWZpeE1hcCA9IHtcbiAgdGV4dD86IE1lc3NhZ2U7XG4gIGZ1bmN0aW9uX2NhbGw/OiBNZXNzYWdlICYge1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnO1xuICAgIGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbDtcbiAgfTtcbiAgdG9vbF9jYWxscz86IE1lc3NhZ2UgJiB7XG4gICAgcm9sZTogJ2Fzc2lzdGFudCc7XG4gICAgdG9vbF9jYWxsczogVG9vbENhbGxbXTtcbiAgfTtcbiAgZGF0YTogSlNPTlZhbHVlW107XG59O1xuXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZTxUIGV4dGVuZHMgTWVzc2FnZSB8IG51bGwgfCB1bmRlZmluZWQ+KFxuICBtZXNzYWdlOiBULFxuICBhbm5vdGF0aW9uczogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQsXG4pOiBUIHtcbiAgaWYgKCFtZXNzYWdlIHx8ICFhbm5vdGF0aW9ucyB8fCAhYW5ub3RhdGlvbnMubGVuZ3RoKSByZXR1cm4gbWVzc2FnZTtcbiAgcmV0dXJuIHsgLi4ubWVzc2FnZSwgYW5ub3RhdGlvbnM6IFsuLi5hbm5vdGF0aW9uc10gfSBhcyBUO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICByZWFkZXIsXG4gIGFib3J0Q29udHJvbGxlclJlZixcbiAgdXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZCA9IG5hbm9pZCxcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiBuZXcgRGF0ZSgpLFxufToge1xuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PjtcbiAgYWJvcnRDb250cm9sbGVyUmVmPzoge1xuICAgIGN1cnJlbnQ6IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG4gIH07XG4gIHVwZGF0ZTogKG1lcmdlZDogTWVzc2FnZVtdLCBkYXRhOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgb25GaW5pc2g/OiAocHJlZml4TWFwOiBQcmVmaXhNYXApID0+IHZvaWQ7XG4gIGdlbmVyYXRlSWQ/OiAoKSA9PiBzdHJpbmc7XG4gIGdldEN1cnJlbnREYXRlPzogKCkgPT4gRGF0ZTtcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgcHJlZml4TWFwOiBQcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW10sXG4gIH07XG5cbiAgLy8ga2VlcCBsaXN0IG9mIGN1cnJlbnQgbWVzc2FnZSBhbm5vdGF0aW9ucyBmb3IgbWVzc2FnZVxuICBsZXQgbWVzc2FnZV9hbm5vdGF0aW9uczogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgLy8gd2UgY3JlYXRlIGEgbWFwIG9mIGVhY2ggcHJlZml4LCBhbmQgZm9yIGVhY2ggcHJlZml4ZWQgbWVzc2FnZSB3ZSBwdXNoIHRvIHRoZSBtYXBcbiAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXJSZWY/LmN1cnJlbnQgPT09IG51bGwsXG4gIH0pKSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgaWYgKHByZWZpeE1hcFsndGV4dCddKSB7XG4gICAgICAgIHByZWZpeE1hcFsndGV4dCddID0ge1xuICAgICAgICAgIC4uLnByZWZpeE1hcFsndGV4dCddLFxuICAgICAgICAgIGNvbnRlbnQ6IChwcmVmaXhNYXBbJ3RleHQnXS5jb250ZW50IHx8ICcnKSArIHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb25fY2FsbCcpIHtcbiAgICAgIHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddO1xuICAgIH1cblxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAndG9vbF9jYWxscycpIHtcbiAgICAgIHByZWZpeE1hcFsndG9vbF9jYWxscyddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIH07XG5cbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsndG9vbF9jYWxscyddO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnZGF0YScpIHtcbiAgICAgIHByZWZpeE1hcFsnZGF0YSddLnB1c2goLi4udmFsdWUpO1xuICAgIH1cblxuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbJ3RleHQnXTtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZV9hbm5vdGF0aW9ucycpIHtcbiAgICAgIGlmICghbWVzc2FnZV9hbm5vdGF0aW9ucykge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zID0gWy4uLnZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMucHVzaCguLi52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBhbnkgZXhpc3RpbmcgbWVzc2FnZSB3aXRoIHRoZSBsYXRlc3QgYW5ub3RhdGlvbnNcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwWydmdW5jdGlvbl9jYWxsJ10sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMsXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFsndG9vbF9jYWxscyddLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLFxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8ga2VlcHMgdGhlIHByZWZpeE1hcCB1cCB0byBkYXRlIHdpdGggdGhlIGxhdGVzdCBhbm5vdGF0aW9ucywgZXZlbiBpZiBhbm5vdGF0aW9ucyBwcmVjZWRlZCB0aGUgbWVzc2FnZVxuICAgIGlmIChtZXNzYWdlX2Fubm90YXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VQcmVmaXhLZXlzOiAoa2V5b2YgUHJlZml4TWFwKVtdID0gW1xuICAgICAgICAndGV4dCcsXG4gICAgICAgICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgICAgJ3Rvb2xfY2FsbHMnLFxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHByZWZpeE1hcFtrZXldKSB7XG4gICAgICAgICAgKHByZWZpeE1hcFtrZXldIGFzIE1lc3NhZ2UpLmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VfYW5ub3RhdGlvbnMhXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2UgYWRkIGZ1bmN0aW9uICYgdG9vbCBjYWxscyBhbmQgcmVzcG9uc2UgbWVzc2FnZXMgdG8gdGhlIG1lc3NhZ2VzW10sIGJ1dCBkYXRhIGlzIGl0cyBvd24gdGhpbmdcbiAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgdG9vbENhbGxNZXNzYWdlLCByZXNwb25zZU1lc3NhZ2VdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAubWFwKG1lc3NhZ2UgPT4gKHtcbiAgICAgICAgLi4uYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UobWVzc2FnZSwgbWVzc2FnZV9hbm5vdGF0aW9ucyksXG4gICAgICB9KSkgYXMgTWVzc2FnZVtdO1xuXG4gICAgdXBkYXRlKG1lcmdlZCwgWy4uLnByZWZpeE1hcFsnZGF0YSddXSk7IC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBkYXRhIGFycmF5XG4gIH1cblxuICBvbkZpbmlzaD8uKHByZWZpeE1hcCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogW1xuICAgICAgcHJlZml4TWFwLnRleHQsXG4gICAgICBwcmVmaXhNYXAuZnVuY3Rpb25fY2FsbCxcbiAgICAgIHByZWZpeE1hcC50b29sX2NhbGxzLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzIE1lc3NhZ2VbXSxcbiAgICBkYXRhOiBwcmVmaXhNYXAuZGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IHBhcnNlQ29tcGxleFJlc3BvbnNlIH0gZnJvbSAnLi9wYXJzZS1jb21wbGV4LXJlc3BvbnNlJztcbmltcG9ydCB7XG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSWRHZW5lcmF0b3IsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQ09NUExFWF9IRUFERVIsIGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENoYXRBcGkoe1xuICBhcGksXG4gIG1lc3NhZ2VzLFxuICBib2R5LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYWJvcnRDb250cm9sbGVyLFxuICBhcHBlbmRNZXNzYWdlLFxuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uVXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZCxcbn06IHtcbiAgYXBpOiBzdHJpbmc7XG4gIG1lc3NhZ2VzOiBPbWl0PE1lc3NhZ2UsICdpZCc+W107XG4gIGJvZHk6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIGNyZWRlbnRpYWxzPzogUmVxdWVzdENyZWRlbnRpYWxzO1xuICBoZWFkZXJzPzogSGVhZGVyc0luaXQ7XG4gIGFib3J0Q29udHJvbGxlcj86ICgpID0+IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZTogKCkgPT4gdm9pZDtcbiAgYXBwZW5kTWVzc2FnZTogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQ7XG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25VcGRhdGU6IChtZXJnZWQ6IE1lc3NhZ2VbXSwgZGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIG9uRmluaXNoPzogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQ7XG4gIGdlbmVyYXRlSWQ6IElkR2VuZXJhdG9yO1xufSkge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgLi4uYm9keSxcbiAgICB9KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgLi4uaGVhZGVycyxcbiAgICB9LFxuICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyPy4oKT8uc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzLFxuICB9KS5jYXRjaChlcnIgPT4ge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG5cbiAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgb25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIChhd2FpdCByZXNwb25zZS50ZXh0KCkpIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuJyxcbiAgICApO1xuICB9XG5cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgfVxuXG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChDT01QTEVYX0hFQURFUikgPT09ICd0cnVlJztcblxuICBpZiAoaXNDb21wbGV4TW9kZSkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICByZWFkZXIsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWY6XG4gICAgICAgIGFib3J0Q29udHJvbGxlciAhPSBudWxsID8geyBjdXJyZW50OiBhYm9ydENvbnRyb2xsZXIoKSB9IDogdW5kZWZpbmVkLFxuICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgIG9uRmluaXNoKHByZWZpeE1hcCkge1xuICAgICAgICBpZiAob25GaW5pc2ggJiYgcHJlZml4TWFwLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIG9uRmluaXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlSWQsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoZmFsc2UpO1xuXG4gICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBSZW1vdmUgdGhpcyBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICBsZXQgc3RyZWFtZWRSZXNwb25zZSA9ICcnO1xuICAgIGNvbnN0IHJlcGx5SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogJycsXG4gICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICB9O1xuXG4gICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBSZW1vdmUgdGhpcyBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIHRoZSBjaGF0IHN0YXRlIHdpdGggdGhlIG5ldyBtZXNzYWdlIHRva2Vucy5cbiAgICAgIHN0cmVhbWVkUmVzcG9uc2UgKz0gZGVjb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICAgIC8vIFdoaWxlIHRoZSBmdW5jdGlvbiBjYWxsIGlzIHN0cmVhbWluZywgaXQgd2lsbCBiZSBhIHN0cmluZy5cbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlWydmdW5jdGlvbl9jYWxsJ10gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSkge1xuICAgICAgICAvLyBXaGlsZSB0aGUgdG9vbCBjYWxscyBhcmUgc3RyZWFtaW5nLCBpdCB3aWxsIGJlIGEgc3RyaW5nLlxuICAgICAgICByZXNwb25zZU1lc3NhZ2VbJ3Rvb2xfY2FsbHMnXSA9IHN0cmVhbWVkUmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbJ2NvbnRlbnQnXSA9IHN0cmVhbWVkUmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZE1lc3NhZ2UoeyAuLi5yZXNwb25zZU1lc3NhZ2UgfSk7XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgICAgaWYgKGFib3J0Q29udHJvbGxlcj8uKCkgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykpIHtcbiAgICAgIC8vIE9uY2UgdGhlIHN0cmVhbSBpcyBjb21wbGV0ZSwgdGhlIGZ1bmN0aW9uIGNhbGwgaXMgcGFyc2VkIGludG8gYW4gb2JqZWN0LlxuICAgICAgY29uc3QgcGFyc2VkRnVuY3Rpb25DYWxsOiBGdW5jdGlvbkNhbGwgPVxuICAgICAgICBKU09OLnBhcnNlKHN0cmVhbWVkUmVzcG9uc2UpLmZ1bmN0aW9uX2NhbGw7XG5cbiAgICAgIHJlc3BvbnNlTWVzc2FnZVsnZnVuY3Rpb25fY2FsbCddID0gcGFyc2VkRnVuY3Rpb25DYWxsO1xuXG4gICAgICBhcHBlbmRNZXNzYWdlKHsgLi4ucmVzcG9uc2VNZXNzYWdlIH0pO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpIHtcbiAgICAgIC8vIE9uY2UgdGhlIHN0cmVhbSBpcyBjb21wbGV0ZSwgdGhlIHRvb2wgY2FsbHMgYXJlIHBhcnNlZCBpbnRvIGFuIGFycmF5LlxuICAgICAgY29uc3QgcGFyc2VkVG9vbENhbGxzOiBUb29sQ2FsbFtdID1cbiAgICAgICAgSlNPTi5wYXJzZShzdHJlYW1lZFJlc3BvbnNlKS50b29sX2NhbGxzO1xuXG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ3Rvb2xfY2FsbHMnXSA9IHBhcnNlZFRvb2xDYWxscztcblxuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG5cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2hhdFJlcXVlc3QsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBNZXNzYWdlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIHVwZGF0ZUNoYXRSZXF1ZXN0LFxuICBnZXRDdXJyZW50TWVzc2FnZXMsXG59OiB7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+IFByb21pc2U8XG4gICAgTWVzc2FnZSB8IHsgbWVzc2FnZXM6IE1lc3NhZ2VbXTsgZGF0YTogSlNPTlZhbHVlW10gfVxuICA+O1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgY2hhdE1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gICAgZnVuY3Rpb25DYWxsOiBGdW5jdGlvbkNhbGwsXG4gICkgPT4gUHJvbWlzZTx2b2lkIHwgQ2hhdFJlcXVlc3Q+O1xuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbD86IChcbiAgICBjaGF0TWVzc2FnZXM6IE1lc3NhZ2VbXSxcbiAgICB0b29sQ2FsbHM6IFRvb2xDYWxsW10sXG4gICkgPT4gUHJvbWlzZTx2b2lkIHwgQ2hhdFJlcXVlc3Q+O1xuICB1cGRhdGVDaGF0UmVxdWVzdDogKGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCkgPT4gdm9pZDtcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBNZXNzYWdlW107XG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBUaGlzIHNob3VsZCBiZSB7ICBjb25zdCB7IG1lc3NhZ2VzOiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZXMsIGRhdGEgfSA9XG4gICAgLy8gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSh9IG9uY2UgU3RyZWFtIERhdGEgaXMgbm90IGV4cGVyaW1lbnRhbFxuICAgIGNvbnN0IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UgPSBhd2FpdCBnZXRTdHJlYW1lZFJlc3BvbnNlKCk7XG5cbiAgICAvLyBVc2luZyBleHBlcmltZW50YWwgc3RyZWFtIGRhdGFcbiAgICBpZiAoJ21lc3NhZ2VzJyBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgLy8gU2VlIGlmIHRoZSBtZXNzYWdlIGhhcyBhIGNvbXBsZXRlIGZ1bmN0aW9uIGNhbGwgb3IgdG9vbCBjYWxsXG4gICAgICAgIGlmIChcbiAgICAgICAgICAobWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgIChtZXNzYWdlLnRvb2xfY2FsbHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gJ3N0cmluZycpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAvLyBUcnkgdG8gaGFuZGxlIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IG1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25DYWxsIGlzIGFuIG9iamVjdFxuICAgICAgICAgIC8vIElmIG5vdCwgd2UgZ290IHRvb2wgY2FsbHMgaW5zdGVhZCBvZiBmdW5jdGlvbiBjYWxsc1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25DYWxsICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2VyIGhhbmRsZXMgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gdGhlaXIgb3duIGZ1bmN0aW9uQ2FsbEhhbmRsZXIuXG4gICAgICAgICAgLy8gVGhlIFwiYXJndW1lbnRzXCIga2V5IG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9iamVjdCB3aWxsIHN0aWxsIGJlIGEgc3RyaW5nIHdoaWNoIHdpbGwgaGF2ZSB0byBiZSBwYXJzZWQgaW4gdGhlIGZ1bmN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgLy8gSWYgdGhlIFwiYXJndW1lbnRzXCIgSlNPTiBpcyBtYWxmb3JtZWQgZHVlIHRvIG1vZGVsIGVycm9yIHRoZSB1c2VyIHdpbGwgaGF2ZSB0byBoYW5kbGUgdGhhdCB0aGVtc2VsdmVzLlxuXG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlcygpLFxuICAgICAgICAgICAgICBmdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBoYW5kbGUgdG9vbCBjYWxsXG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IG1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9vbENhbGxzIGlzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgICAvLyBJZiBub3QsIHdlIGdvdCBmdW5jdGlvbiBjYWxscyBpbnN0ZWFkIG9mIHRvb2wgY2FsbHNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0b29sQ2FsbHMpIHx8XG4gICAgICAgICAgICB0b29sQ2FsbHMuc29tZSh0b29sQ2FsbCA9PiB0eXBlb2YgdG9vbENhbGwgIT09ICdvYmplY3QnKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVzZXIgaGFuZGxlcyB0aGUgZnVuY3Rpb24gY2FsbCBpbiB0aGVpciBvd24gZnVuY3Rpb25DYWxsSGFuZGxlci5cbiAgICAgICAgICAvLyBUaGUgXCJhcmd1bWVudHNcIiBrZXkgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgb2JqZWN0IHdpbGwgc3RpbGwgYmUgYSBzdHJpbmcgd2hpY2ggd2lsbCBoYXZlIHRvIGJlIHBhcnNlZCBpbiB0aGUgZnVuY3Rpb24gaGFuZGxlci5cbiAgICAgICAgICAvLyBJZiB0aGUgXCJhcmd1bWVudHNcIiBKU09OIGlzIG1hbGZvcm1lZCBkdWUgdG8gbW9kZWwgZXJyb3IgdGhlIHVzZXIgd2lsbCBoYXZlIHRvIGhhbmRsZSB0aGF0IHRoZW1zZWx2ZXMuXG4gICAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAgIC8vIFRoZSB1cGRhdGVkIGNoYXQgd2l0aCBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdpbGwgYmUgc2VudCB0byB0aGUgQVBJIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC5cbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuXG4gICAgICAvLyBUT0RPLVNUUkVBTURBVEE6IFJlbW92ZSB0aGlzIG9uY2UgU3RyZWFtIERhdGEgaXMgbm90IGV4cGVyaW1lbnRhbFxuICAgICAgaWYgKFxuICAgICAgICAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09ICdzdHJpbmcnKVxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgYXJlIGV4cGVjdGluZyBhIGZ1bmN0aW9uIGNhbGwsIHRoZSBtZXNzYWdlIHNob3VsZCBoYXZlIG9uZSwgaWYgbm90IHdhcm4gYW5kIGNvbnRpbnVlXG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIGlmICghKHR5cGVvZiBmdW5jdGlvbkNhbGwgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCBmdW5jdGlvbkNhbGwpO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyhmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGdldCBoZXJlIGFuZCBhcmUgZXhwZWN0aW5nIGEgdG9vbCBjYWxsLCB0aGUgbWVzc2FnZSBzaG91bGQgaGF2ZSBvbmUsIGlmIG5vdCB3YXJuIGFuZCBjb250aW51ZVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgIGlmICghKHR5cGVvZiB0b29sQ2FsbHMgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyBmdW5jdGlvbnMnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cyBhcmUgc2VudCBiYWNrIHRvIHRoZSBBUEkgYXMgYSBzdHJpbmdcbiAgICAgIGZ1bmN0aW9uIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyhyZXNwb25zZTogQ2hhdFJlcXVlc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHJlc3BvbnNlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvb2xDYWxsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InO1xuaW1wb3J0IHsgY2FsbENvbXBsZXRpb25BcGkgfSBmcm9tICcuLi9zaGFyZWQvY2FsbC1jb21wbGV0aW9uLWFwaSc7XG5pbXBvcnQge1xuICBKU09OVmFsdWUsXG4gIFJlcXVlc3RPcHRpb25zLFxuICBVc2VDb21wbGV0aW9uT3B0aW9ucyxcbn0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgVXNlQ29tcGxldGlvbkhlbHBlcnMgPSB7XG4gIC8qKiBUaGUgY3VycmVudCBjb21wbGV0aW9uIHJlc3VsdCAqL1xuICBjb21wbGV0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTZW5kIGEgbmV3IHByb21wdCB0byB0aGUgQVBJIGVuZHBvaW50IGFuZCB1cGRhdGUgdGhlIGNvbXBsZXRpb24gc3RhdGUuXG4gICAqL1xuICBjb21wbGV0ZTogKFxuICAgIHByb21wdDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAvKiogVGhlIGVycm9yIG9iamVjdCBvZiB0aGUgQVBJIHJlcXVlc3QgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IEVycm9yO1xuICAvKipcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgQVBJIHJlcXVlc3QgYnV0IGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMuXG4gICAqL1xuICBzdG9wOiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBgY29tcGxldGlvbmAgc3RhdGUgbG9jYWxseS5cbiAgICovXG4gIHNldENvbXBsZXRpb246IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XG4gIC8qKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgKi9cbiAgaW5wdXQ6IHN0cmluZztcbiAgLyoqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuICAvKipcbiAgICogQW4gaW5wdXQvdGV4dGFyZWEtcmVhZHkgb25DaGFuZ2UgaGFuZGxlciB0byBjb250cm9sIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIDxpbnB1dCBvbkNoYW5nZT17aGFuZGxlSW5wdXRDaGFuZ2V9IHZhbHVlPXtpbnB1dH0gLz5cbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGU6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IGlucHV0IGFuZCBhcHBlbmQgYSB1c2VyIG1lc3NhZ2VcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9PlxuICAgKiAgPGlucHV0IG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX0gdmFsdWU9e2lucHV0fSAvPlxuICAgKiA8L2Zvcm0+XG4gICAqIGBgYFxuICAgKi9cbiAgaGFuZGxlU3VibWl0OiAoZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHZvaWQ7XG4gIC8qKiBXaGV0aGVyIHRoZSBBUEkgcmVxdWVzdCBpcyBpbiBwcm9ncmVzcyAqL1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIC8qKiBBZGRpdGlvbmFsIGRhdGEgYWRkZWQgb24gdGhlIHNlcnZlciB2aWEgU3RyZWFtRGF0YSAqL1xuICBkYXRhPzogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tcGxldGlvbih7XG4gIGFwaSA9ICcvYXBpL2NvbXBsZXRpb24nLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSAnJyxcbiAgaW5pdGlhbElucHV0ID0gJycsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbn06IFVzZUNvbXBsZXRpb25PcHRpb25zID0ge30pOiBVc2VDb21wbGV0aW9uSGVscGVycyB7XG4gIC8vIEdlbmVyYXRlIGFuIHVuaXF1ZSBpZCBmb3IgdGhlIGNvbXBsZXRpb24gaWYgbm90IHByb3ZpZGVkLlxuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCB8fCBob29rSWQ7XG5cbiAgLy8gU3RvcmUgdGhlIGNvbXBsZXRpb24gc3RhdGUgaW4gU1dSLCB1c2luZyB0aGUgY29tcGxldGlvbklkIGFzIHRoZSBrZXkgdG8gc2hhcmUgc3RhdGVzLlxuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSPHN0cmluZz4oW2FwaSwgY29tcGxldGlvbklkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbENvbXBsZXRpb24sXG4gIH0pO1xuXG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSPGJvb2xlYW4+KFxuICAgIFtjb21wbGV0aW9uSWQsICdsb2FkaW5nJ10sXG4gICAgbnVsbCxcbiAgKTtcblxuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSPFxuICAgIEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkXG4gID4oW2NvbXBsZXRpb25JZCwgJ3N0cmVhbURhdGEnXSwgbnVsbCk7XG5cbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBFcnJvcj4odW5kZWZpbmVkKTtcbiAgY29uc3QgY29tcGxldGlvbiA9IGRhdGEhO1xuXG4gIC8vIEFib3J0IGNvbnRyb2xsZXIgdG8gY2FuY2VsIHRoZSBjdXJyZW50IEFQSSBjYWxsLlxuICBjb25zdCBbYWJvcnRDb250cm9sbGVyLCBzZXRBYm9ydENvbnRyb2xsZXJdID1cbiAgICB1c2VTdGF0ZTxBYm9ydENvbnRyb2xsZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG5cbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAocHJvbXB0OiBzdHJpbmcsIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucykgPT5cbiAgICAgIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgICAgICAgYXBpLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAgIC4uLm9wdGlvbnM/LmJvZHksXG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbXBsZXRpb246IGNvbXBsZXRpb24gPT4gbXV0YXRlKGNvbXBsZXRpb24sIGZhbHNlKSxcbiAgICAgICAgc2V0TG9hZGluZzogbXV0YXRlTG9hZGluZyxcbiAgICAgICAgc2V0RXJyb3IsXG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uRGF0YTogZGF0YSA9PiB7XG4gICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uKHN0cmVhbURhdGEgfHwgW10pLCAuLi4oZGF0YSB8fCBbXSldLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIHN0cmVhbURhdGEsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICB9XG4gIH0sIFthYm9ydENvbnRyb2xsZXJdKTtcblxuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgKGNvbXBsZXRpb246IHN0cmluZykgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24sIGZhbHNlKTtcbiAgICB9LFxuICAgIFttdXRhdGVdLFxuICApO1xuXG4gIGNvbnN0IGNvbXBsZXRlID0gdXNlQ2FsbGJhY2s8VXNlQ29tcGxldGlvbkhlbHBlcnNbJ2NvbXBsZXRlJ10+KFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChwcm9tcHQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XSxcbiAgKTtcblxuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKGluaXRpYWxJbnB1dCk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm47XG4gICAgICByZXR1cm4gY29tcGxldGUoaW5wdXQpO1xuICAgIH0sXG4gICAgW2lucHV0LCBjb21wbGV0ZV0sXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZTogYW55KSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHsgSlNPTlZhbHVlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBDT01QTEVYX0hFQURFUiwgY3JlYXRlQ2h1bmtEZWNvZGVyIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gIGFwaSxcbiAgcHJvbXB0LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIG9uRGF0YSxcbn06IHtcbiAgYXBpOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xuICBjcmVkZW50aWFscz86IFJlcXVlc3RDcmVkZW50aWFscztcbiAgaGVhZGVycz86IEhlYWRlcnNJbml0O1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRMb2FkaW5nOiAobG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0RXJyb3I6IChlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIHNldEFib3J0Q29udHJvbGxlcjogKGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbCkgPT4gdm9pZDtcbiAgb25SZXNwb25zZT86IChyZXNwb25zZTogUmVzcG9uc2UpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICBvbkZpbmlzaD86IChwcm9tcHQ6IHN0cmluZywgY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgb25EYXRhPzogKGRhdGE6IEpTT05WYWx1ZVtdKSA9PiB2b2lkO1xufSkge1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBzZXRBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcblxuICAgIC8vIEVtcHR5IHRoZSBjb21wbGV0aW9uIGltbWVkaWF0ZWx5LlxuICAgIHNldENvbXBsZXRpb24oJycpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5LFxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcblxuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChhd2FpdCByZXMudGV4dCgpKSB8fCAnRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgY29uc3QgaXNDb21wbGV4TW9kZSA9IHJlcy5oZWFkZXJzLmdldChDT01QTEVYX0hFQURFUikgPT09ICd0cnVlJztcblxuICAgIGlmIChpc0NvbXBsZXhNb2RlKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICAgICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwsXG4gICAgICB9KSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2RhdGEnOiB7XG4gICAgICAgICAgICBvbkRhdGE/Lih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjb21wbGV0aW9uIHN0YXRlIHdpdGggdGhlIG5ldyBtZXNzYWdlIHRva2Vucy5cbiAgICAgICAgcmVzdWx0ICs9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWdub3JlIGFib3J0IGVycm9ycyBhcyB0aGV5IGFyZSBleHBlY3RlZC5cbiAgICBpZiAoKGVyciBhcyBhbnkpLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0RXJyb3IoZXJyIGFzIEVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3MgKi9cblxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtJztcbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRTdGF0dXMgPSAnaW5fcHJvZ3Jlc3MnIHwgJ2F3YWl0aW5nX21lc3NhZ2UnO1xuXG5leHBvcnQgdHlwZSBVc2VBc3Npc3RhbnRIZWxwZXJzID0ge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYXJyYXkgb2YgY2hhdCBtZXNzYWdlcy5cbiAgICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRocmVhZCBJRC5cbiAgICovXG4gIHRocmVhZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIGlucHV0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUuXG4gICAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIHRoZSBgb25DaGFuZ2VgIGV2ZW50IG9mIHRoZSBpbnB1dCBmaWVsZCB0byBjb250cm9sIHRoZSBpbnB1dCdzIHZhbHVlLlxuICAgKi9cbiAgaGFuZGxlSW5wdXRDaGFuZ2U6IChcbiAgICBldmVudDpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4gdm9pZDtcblxuICAvKipcbiAgICogRm9ybSBzdWJtaXNzaW9uIGhhbmRsZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHJlc2V0cyB0aGUgaW5wdXQgZmllbGQgYW5kIGFwcGVuZHMgYSB1c2VyIG1lc3NhZ2UuXG4gICAqL1xuICBzdWJtaXRNZXNzYWdlOiAoXG4gICAgZXZlbnQ/OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2hvdyBhIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgKi9cbiAgc3RhdHVzOiBBc3Npc3RhbnRTdGF0dXM7XG5cbiAgLyoqXG4gICAqIFRoZSBlcnJvciB0aHJvd24gZHVyaW5nIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBwcm9jZXNzaW5nLCBpZiBhbnkuXG4gICAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgdW5rbm93bjtcbn07XG5cbmV4cG9ydCB0eXBlIFVzZUFzc2lzdGFudE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBUaGUgQVBJIGVuZHBvaW50IHRoYXQgYWNjZXB0cyBhIGB7IHRocmVhZElkOiBzdHJpbmcgfCBudWxsOyBtZXNzYWdlOiBzdHJpbmc7IH1gIG9iamVjdCBhbmQgcmV0dXJucyBhbiBgQXNzaXN0YW50UmVzcG9uc2VgIHN0cmVhbS5cbiAgICogVGhlIHRocmVhZElkIHJlZmVycyB0byBhbiBleGlzdGluZyB0aHJlYWQgd2l0aCBtZXNzYWdlcyAob3IgaXMgYG51bGxgIHRvIGNyZWF0ZSBhIG5ldyB0aHJlYWQpLlxuICAgKiBUaGUgbWVzc2FnZSBpcyB0aGUgbmV4dCBtZXNzYWdlIHRoYXQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSB0aHJlYWQgYW5kIHNlbnQgdG8gdGhlIGFzc2lzdGFudC5cbiAgICovXG4gIGFwaTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBJRCBvZiBhbiBleGlzdGluZyB0aHJlYWQuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHRocmVhZElkPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBsaXRlcmFsIHRoYXQgc2V0cyB0aGUgbW9kZSBvZiBjcmVkZW50aWFscyB0byBiZSB1c2VkIG9uIHRoZSByZXF1ZXN0LlxuICAgKiBEZWZhdWx0cyB0byBcInNhbWUtb3JpZ2luXCIuXG4gICAqL1xuICBjcmVkZW50aWFscz86IFJlcXVlc3RDcmVkZW50aWFscztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgb2JqZWN0IG9mIGhlYWRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBBUEkgZW5kcG9pbnQuXG4gICAqL1xuICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IEhlYWRlcnM7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGJvZHkgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgQVBJIGVuZHBvaW50LlxuICAgKi9cbiAgYm9keT86IG9iamVjdDtcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhc3Npc3RhbnQgZW5jb3VudGVycyBhbiBlcnJvci5cbiAgICovXG4gIG9uRXJyb3I/OiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQoe1xuICBhcGksXG4gIHRocmVhZElkOiB0aHJlYWRJZFBhcmFtLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25FcnJvcixcbn06IFVzZUFzc2lzdGFudE9wdGlvbnMpOiBVc2VBc3Npc3RhbnRIZWxwZXJzIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFt0aHJlYWRJZCwgc2V0VGhyZWFkSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGU8QXNzaXN0YW50U3RhdHVzPignYXdhaXRpbmdfbWVzc2FnZScpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHVuZGVmaW5lZCB8IEVycm9yPih1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKFxuICAgIGV2ZW50OlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB7XG4gICAgc2V0SW5wdXQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBzdWJtaXRNZXNzYWdlID0gYXN5bmMgKFxuICAgIGV2ZW50PzogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgcmVxdWVzdE9wdGlvbnM/OiB7XG4gICAgICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB9LFxuICApID0+IHtcbiAgICBldmVudD8ucHJldmVudERlZmF1bHQ/LigpO1xuXG4gICAgaWYgKGlucHV0ID09PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFN0YXR1cygnaW5fcHJvZ3Jlc3MnKTtcblxuICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgIC4uLm1lc3NhZ2VzLFxuICAgICAgeyBpZDogJycsIHJvbGU6ICd1c2VyJywgY29udGVudDogaW5wdXQgfSxcbiAgICBdKTtcblxuICAgIHNldElucHV0KCcnKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgLi4uaGVhZGVycyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAuLi5ib2R5LFxuICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgIHRocmVhZElkOiB0aHJlYWRJZFBhcmFtID8/IHRocmVhZElkID8/IG51bGwsXG4gICAgICAgIG1lc3NhZ2U6IGlucHV0LFxuXG4gICAgICAgIC8vIG9wdGlvbmFsIHJlcXVlc3QgZGF0YTpcbiAgICAgICAgZGF0YTogcmVxdWVzdE9wdGlvbnM/LmRhdGEsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShcbiAgICAgICAgcmVzdWx0LmJvZHkuZ2V0UmVhZGVyKCksXG4gICAgICApKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudF9tZXNzYWdlJzoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCxcbiAgICAgICAgICAgICAgICByb2xlOiB2YWx1ZS5yb2xlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmNvbnRlbnRbMF0udGV4dC52YWx1ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZGF0YV9tZXNzYWdlJzoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCA/PyAnJyxcbiAgICAgICAgICAgICAgICByb2xlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgZGF0YTogdmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YSc6IHtcbiAgICAgICAgICAgIHNldFRocmVhZElkKHZhbHVlLnRocmVhZElkKTtcblxuICAgICAgICAgICAgLy8gc2V0IGlkIG9mIGxhc3QgbWVzc2FnZTpcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuaWQgPSB2YWx1ZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIHJldHVybiBbLi4ubWVzc2FnZXMuc2xpY2UoMCwgbWVzc2FnZXMubGVuZ3RoIC0gMSksIGxhc3RNZXNzYWdlXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gbmV3IEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVycm9yT2JqKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob25FcnJvciAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBzZXRFcnJvcihlcnJvciBhcyBFcnJvcik7XG4gICAgfVxuXG4gICAgc2V0U3RhdHVzKCdhd2FpdGluZ19tZXNzYWdlJyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICB0aHJlYWRJZCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBzdWJtaXRNZXNzYWdlLFxuICAgIHN0YXR1cyxcbiAgICBlcnJvcixcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZUlkIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTV1IiLCJ0ZXh0U3RyZWFtUGFydCIsImNvZGUiLCJuYW1lIiwicGFyc2UiLCJ2YWx1ZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwicm9sZSIsImNvbnRlbnQiLCJldmVyeSIsIml0ZW0iLCJ0ZXh0IiwiYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0IiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJkYXRhTWVzc2FnZVN0cmVhbVBhcnQiLCJ0b29sQ2FsbFN0cmVhbVBhcnQiLCJ0b29sX2NhbGxzIiwic29tZSIsInRjIiwiZnVuY3Rpb24iLCJtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Iiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsIk5FV0xJTkUiLCJjaGFyQ29kZUF0IiwiY29uY2F0Q2h1bmtzIiwiY2h1bmtzIiwidG90YWxMZW5ndGgiLCJjb25jYXRlbmF0ZWRDaHVua3MiLCJVaW50OEFycmF5Iiwib2Zmc2V0IiwiY2h1bmsiLCJzZXQiLCJsZW5ndGgiLCJyZWFkRGF0YVN0cmVhbSIsInJlYWRlciIsImlzQWJvcnRlZCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsInJlYWQiLCJwdXNoIiwiZGVjb2RlIiwic3RyZWFtIiwic3BsaXQiLCJmaWx0ZXIiLCJzdHJlYW1QYXJ0IiwiY2FuY2VsIiwiY3VzdG9tQWxwaGFiZXQiLCJuYW5vaWQiLCJjcmVhdGVDaHVua0RlY29kZXIiLCJjb21wbGV4IiwiZGVjb2RlZCIsIkJvb2xlYW4iLCJDT01QTEVYX0hFQURFUiIsImFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlIiwibWVzc2FnZSIsImFubm90YXRpb25zIiwicGFyc2VDb21wbGV4UmVzcG9uc2UiLCJhYm9ydENvbnRyb2xsZXJSZWYiLCJ1cGRhdGUiLCJvbkZpbmlzaCIsImdlbmVyYXRlSWQiLCJnZXRDdXJyZW50RGF0ZSIsIkRhdGUiLCJjcmVhdGVkQXQiLCJwcmVmaXhNYXAiLCJkYXRhIiwibWVzc2FnZV9hbm5vdGF0aW9ucyIsImN1cnJlbnQiLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwidG9vbENhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVzc2FnZVByZWZpeEtleXMiLCJmb3JFYWNoIiwia2V5IiwibWVyZ2VkIiwibWVzc2FnZXMiLCJjYWxsQ2hhdEFwaSIsImFwaSIsImJvZHkiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJhYm9ydENvbnRyb2xsZXIiLCJhcHBlbmRNZXNzYWdlIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsImlzQ29tcGxleE1vZGUiLCJnZXQiLCJzdHJlYW1lZFJlc3BvbnNlIiwicmVwbHlJZCIsImRvbmUiLCJzdGFydHNXaXRoIiwicGFyc2VkRnVuY3Rpb25DYWxsIiwicGFyc2VkVG9vbENhbGxzIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsImZ1bmN0aW9uQ2FsbCIsImNvbnNvbGUiLCJ3YXJuIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2UiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsInRvb2xDYWxsUmVzcG9uc2UiLCJmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMiLCJzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSIsImNoYXRSZXF1ZXN0IiwibXV0YXRlIiwibXV0YXRlU3RyZWFtRGF0YSIsImV4aXN0aW5nRGF0YSIsImV4dHJhTWV0YWRhdGFSZWYiLCJtZXNzYWdlc1JlZiIsInNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMiLCJfYiIsInByZXZpb3VzTWVzc2FnZXMiLCJjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCIsInRvb2xfY2FsbF9pZCIsInJlYWRSb3ciLCJwcm9taXNlIiwidWkiLCJuZXh0IiwiZSIsIm9wdGlvbnMiLCJmdW5jdGlvbnMiLCJ0b29scyIsInRvb2xfY2hvaWNlIiwidXNlQ2hhdCIsImluaXRpYWxNZXNzYWdlcyIsImluaXRpYWxJbnB1dCIsIm9uRXJyb3IiLCJob29rSWQiLCJpZEtleSIsImNoYXRLZXkiLCJpbml0aWFsTWVzc2FnZXNGYWxsYmFjayIsImZhbGxiYWNrRGF0YSIsImlzTG9hZGluZyIsIm11dGF0ZUxvYWRpbmciLCJzdHJlYW1EYXRhIiwiZXJyb3IiLCJzZXRFcnJvciIsInRyaWdnZXJSZXF1ZXN0IiwiQWJvcnRDb250cm9sbGVyIiwiY2hhdFJlcXVlc3RQYXJhbSIsImFwcGVuZCIsImNvbmNhdCIsInJlbG9hZCIsImxhc3RNZXNzYWdlIiwic3RvcCIsImFib3J0Iiwic2V0TWVzc2FnZXMiLCJpbnB1dCIsInNldElucHV0IiwiaGFuZGxlU3VibWl0IiwibWV0YWRhdGEiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUlucHV0Q2hhbmdlIiwidGFyZ2V0IiwiY2FsbENvbXBsZXRpb25BcGkiLCJwcm9tcHQiLCJzZXRDb21wbGV0aW9uIiwic2V0TG9hZGluZyIsInNldEFib3J0Q29udHJvbGxlciIsIm9uRGF0YSIsInJlcyIsInJlc3VsdCIsInVzZUNvbXBsZXRpb24iLCJpbml0aWFsQ29tcGxldGlvbiIsImNvbXBsZXRpb25JZCIsImNvbXBsZXRpb24iLCJjb21wbGV0ZSIsImV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQiLCJ0aHJlYWRJZFBhcmFtIiwic2V0VGhyZWFkSWQiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJldmVudCIsInN1Ym1pdE1lc3NhZ2UiLCJyZXF1ZXN0T3B0aW9ucyIsImNhbGwiLCJlcnJvck9iaiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;